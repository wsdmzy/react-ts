## 设计模式学习-ts

- 设计模式原则
  1. 开闭原则 对扩展开放，对内修改关闭。保证程序的扩展性好，易于维护和升级。
  2. 单一职责原则 对一个类而言，应该仅有一个引起它变化的原因
  3. 里氏代换原则 子类可以扩展父类的功能，但是不能改变父类原有的功能
  4. 依赖倒置原则 抽象不依赖细节，细节应该依赖抽象。
  5. 接口隔离原则 建立单一接口，代替庞大臃肿的接口。
  6. 最小知识原则 一个对象应该对其他对象有最少的了解。类间解耦，弱耦合。


- 单例模式    (vue-router 跟 vuex 的 install 也是单例)
  - 特点  保证一个类仅有一个实例，并提供一个访问它的全局访问点
    1. 一个实例
    2. 单例类必须自己创建自己的唯一实例
    3. 单例类必须给所有其他对象提供这一实例
  - 优点
    减少内存开支，减少性能开销，避免对资源的多重占用。设置全局的访问点
  - 缺点
    很难扩展，与单一职责原则冲突
 
- 工厂模式    (我们明确地计划不同条件下创建不同实例时)
  定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
  - 优点
    1. 隐藏了对象创建的细节，将产品的实例化过程放到了工厂中实现。
    2. 客户端基本不用关心使用的是哪个产品，只需要知道用工厂的那个方法(或传入什么参数)就行了.
    3. 方便添加新的产品子类，每次只需要修改工厂类传递的类型值就行了。
    4. 遵循了依赖倒转原则。
  - 缺点
    1. 适用于产品子类型差不多, 使用的方法名都相同的情况.
    2. 每添加一个产品子类，都必须在工厂类中添加一个判断分支(或一个方法)，这违背了OCP(开闭原则)。

- 享元模式  (我们要创建 100 个大小相同颜色不同的 div)
  享元模式，运用共享技术，有效地支持大量的细粒度的对象，以避免对象之间拥有相同内容而造成多余的性能开销。
  - 主要作用
    性能优化，当系统创建过多相似的对象而导致内存占用过高，可以采用这种设计模式进行优化。

  享元模式将对象的属性区分为内部状态与外部状态，内部状态在创建的时候赋值，外部状态在实际需要用到的时候进行动态赋值
  - 对于内部状态和外部状态的区分，有几点：
    1. 内部状态存储于对象内部
    2. 内部状态可以被一些对象共享
    3. 内部状态独立于具体场景，通常不会改变
    4. 外部状态取决于具体场景，并根据场景变化，外部状态不能被共享。


- 策略模式
  定义一系列的算法, 把它们一个个封装起来, 并且使它们可相互替换。
  - 优点
    1. 算法可以自由切换。
    2. 避免使用多重条件判断。
    3. 扩展性好，符合开闭原则。
  - 缺点
    1. 策略类会增多。
    2. 所有策略类都需要对外暴露。


- 装饰器模式
  装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
  - 优点
    1. 更好的可读性
    2. 装饰类和被装饰类可以独立发展，不会相互耦合 
    3. 装饰模式是继承的一个替代模式
    4. 装饰模式可以动态扩展一个实现类的功能。
  - 缺点
    1. 多层装饰比较复杂。

- 适配器模式
  适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
  - 优点
    1. 可以让任何两个没有关联的类一起运行。
    2. 提高了类的复用。
    3. 增加了类的透明度。
    4. 灵活性好。
  - 缺点
    1. 过多地使用适配器，会让系统非常零乱，不易整体进行把握。